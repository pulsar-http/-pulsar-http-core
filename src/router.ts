import { file } from "./response";
import type { HTTPMethod, Route, RouteBuilder, RouterHandler } from "./types";
import { ZodError, type ZodSchema, type infer as zInfer } from "zod";

/**
 * Matches a request to one of the available routes.
 * @param routes - An array of routes to match against.
 * @param request - The incoming HTTP request.
 * @returns The matched route, or undefined if no match is found.
 *
 * Example usage:
 * ```typescript
 * import { router, text, matchRoute } from "@pulsar-http/core";
 *
 * const routes = [
 *     router.get('/api/users', async () => text('User List')),
 * ];
 *
 * // Faking the request for the example
 * const route = matchRoute(routes, new Request('http://localhost:3000/api/users'));
 * ```
 *
 * In this example `route` value is:
 *
 * ```typescript
 * {
 *   method: "GET",
 *   path: "/api/users",
 *   handler: [AsyncFunction: AsyncFunction],
 * }
 * ```
 */
export const matchRoute = (routes: Route[], request: Request) => {
  const url = new URL(request.url);

  return routes.find((route) => {
    const routePath = route.path.split("/").filter((part) => part !== "");
    const requestPath = url.pathname.split("/").filter((part) => part !== "");

    if (route.method !== request.method) {
      return false;
    }

    if (routePath.length !== requestPath.length) {
      return false;
    }

    for (let i = 0; i < routePath.length; i++) {
      if (routePath[i].startsWith(":")) {
        continue;
      }

      if (routePath[i] !== requestPath[i]) {
        return false;
      }
    }

    return true;
  });
};

/**
 * Processes a matched route and generates a response.
 * @param matchedRoute - The route that matches the request, if any.
 * @param request - The incoming HTTP request.
 * @returns A response generated by the matched route handler, or a default response if no route is matched.
 *
 * Example usage:
 * ```typescript
 * import { router, text, processRoute } from "@pulsar-http/core";
 *
 * const myRoute = router.get('/api/users', async () => text('User List'));
 *
 * (async () => {
 *     // Fake the request for the example
 *     const request = new Request('http://localhost:3000/api/users');
 *     const response = await processRoute(myRoute, request);
 * })();
 * ```
 *
 * In this example, `response` will be a `Response` object with the body "User List".
 */
export const processRoute = async <S extends ZodSchema>(
  matchedRoute: Route<S> | undefined,
  request: Request,
) => {
  const url = new URL(request.url);

  if (matchedRoute?.handler) {
    const params = getParams(request, matchedRoute.path);
    let body: zInfer<S> | undefined;

    try {
      body = await getBody(request, matchedRoute);
    } catch (e) {
      if (e instanceof Error) {
        return new Response(e.message, { status: 500 });
      }

      if (e instanceof ZodError) {
        return new Response(e.errors.map((error) => error.message).join("\n"), {
          status: 400,
        });
      }
    }

    return matchedRoute.handler(request, params, body);
  }

  if (url.pathname.startsWith("/public")) {
    return file(url.pathname);
  }

  return new Response("Not Found", { status: 404 });
};

/**
 * Extracts parameters from the request URL based on the route path.
 * @typeParam T - The type of the parameters object, defaults to a string key-value object.
 * @param request - The incoming HTTP request.
 * @param routePath - The path template of the matched route.
 * @returns An object containing the extracted parameters.
 *
 * Example usage:
 * ```typescript
 * import { router, text, getParams } from "@pulsar-http/core";
 *
 * const myRoute = router.get('/api/users/:id', async () => text('User List'));
 *
 * // Fake the request for the example
 * const request = new Request('http://localhost:3000/api/users/123');
 * const params = getParams(request, myRoute.path);
 * ```
 *
 * In this example, `params` will be:
 * ```typescript
 * {
 *   id: "123",
 * }
 * ```
 */
export const getParams = (request: Request, routePath: string) => {
  const url = new URL(request.url);
  const routePathParts = routePath.split("/").filter((part) => part !== "");
  const requestPathParts = url.pathname
    .split("/")
    .filter((part) => part !== "");

  return routePathParts.reduce((acc, part, index) => {
    if (part.startsWith(":")) {
      const key = part.slice(1);
      const value = requestPathParts[index];
      return { ...acc, [key]: value };
    }

    return acc;
  }, {});
};

/**
 * Extracts the body from the request and validates it against the route's body schema
 *
 * @param request - The incoming HTTP request
 * @param route - The route that contains the body schema.
 *
 * @returns The body of the request, or null if the route does not have a body schema.
 *
 * Example usage:
 * ```typescript
 * import { router, text, getBody } from "@pulsar-http/core";
 * import z from 'zod';
 *
 * const userSchema = z.object({
 *     name: z.string(),
 *     email: z.string().email(),
 * });
 *
 * // Schema must be passed to the route if you want to use `body` in the handler or `getBody` function.
 * // If not passed, you can retrieve the body from the request object as usual.
 * const myRoute = router.post('/api/users', async () => text('User Created'), userSchema);
 *
 * // Fake the request for the example
 * const request = new Request('http://localhost:3000/api/users', {
 *    method: 'POST',
 *    headers: {
 *      'Content-Type': 'application/json',
 *      'Accept': 'application/json',
 *    },
 *    body: JSON.stringify({ name: 'John Doe', email: 'john@example.com' }),
 * });
 *
 * const body = await getBody(request, myRoute);
 *
 * console.log(body); // Output: { name: 'John Doe', email: 'john@example.com' }
 * ```
 */
export const getBody = async <S extends ZodSchema = ZodSchema>(
  request: Request,
  route: Route<S>,
) => {
  if (!route.bodyValidator) {
    return null;
  }

  const body = await request.json();
  const parseResult = route.bodyValidator.safeParse(body);

  if (parseResult.success) {
    return parseResult.data;
  }

  throw parseResult.error;
};

const route = <S extends ZodSchema<any>>(
  method: HTTPMethod,
  path: string,
  handler: RouterHandler<zInfer<S>>,
  bodyValidator?: S,
): Route<S> => {
  return {
    method,
    path,
    handler,
    bodyValidator,
  };
};

/**
 * List of supported HTTP methods.
 */
const methods: HTTPMethod[] = [
  "GET",
  "POST",
  "PUT",
  "DELETE",
  "PATCH",
  "OPTIONS",
  "HEAD",
  "CONNECT",
  "TRACE",
  "ALL",
];

/**
 * Router object that provides methods for creating routes with various HTTP methods.
 *
 * Example usage:
 * ```typescript
 * import { router, start, text } from "@pulsar-http/core";
 *
 * const routes = [
 *     router.get('/api/users', async (req) => text('User List')),
 *     router.post('/api/users', async (req) => text('User Created')),
 *     router.put('/api/users/:id', async (req, params) => text(`User ${params.id} Updated`)),
 *     router.delete('/api/users/:id', async (req, params) => text(`User ${params.id} Deleted`)),
 * ];
 *
 * start({
 *     routes,
 * });
 * ```
 * This example shows how to create routes using the provided methods, such as `get`, `post`, `put`, and `delete`.
 */
export const router = methods.reduce(
  (acc, method) => {
    acc[method.toLowerCase()] = <S extends ZodSchema<any>>(
      path: string,
      handler: RouterHandler<zInfer<S>>,
      bodyValidator?: S,
    ): Route<S> => route(method, path, handler, bodyValidator);
    return acc;
  },
  {} as Record<string, RouteBuilder>,
);

/**
 * Handles incoming requests by matching them to the appropriate route and processing the response.
 *
 * It is used with Bun.serve in the `start()` function to handle incoming requests and generate the appropriate response.
 *
 * @param routes - An array of available routes.
 * @returns A function that takes an HTTP request and returns the appropriate response.
 *
 * Example usage:
 * ```typescript
 * import { router, text, handleRoutes, log } from "@pulsar-http/core";
 *
 * const routes = [
 *     router.get('/api/users', async () => text('User List')),
 * ];
 *
 *
 * (async () => {
 *     const handler = await handleRoutes(routes);
 *
 *     // Fake a request and get the response
 *     const response = await handler(new Request('http://localhost:3000/api/users'));
 *     const text = await response.text();
 *
 *     log(text); // Output: "[current datetime]: User List"
 * })();
 * ```
 */
export const handleRoutes = async (routes: Route[]) => {
  return async (request: Request) => {
    const route = matchRoute(routes, request);
    return processRoute(route, request);
  };
};
